---
description: Some basic reconaissance techniques for web application pentesting
---

# Web Application Recon

Web applications contain a plethora of information. Some basic recon can give us further insight into the inner workings of the web application and thus expand our attack knowledge and surface.

## Page Source

The information we see on a web page is made up of HTML, CSS and Javascript code. We can view this code with the page source present in almost all browsers. To read the page source, right click inside the browser and look for the option `View Page Source`.&#x20;

<figure><img src="../../.gitbook/assets/Screenshot 2024-05-08 181818.png" alt=""><figcaption><p>View Page Source in Firefox</p></figcaption></figure>

The page source might contain HTML comments which are not rendered by the browser.

```html
<h1>This is a heading!</h1>
<!---This is a comment. The browser will not render me.-->
<p>This is some text.</p>
```

## Indexing

Sometimes the web app's index of directories and files can be publicly accessible. This can give us insight on how the server stores files and might leak some sensitive information. To check if the web app does enabled indexing, carefully go through the page source and try to understand how is the web app accessing information such as images, videos, pages etc.

```html
<img alt="logo" width="35" height="35" src="/images/logo.png">
```

In the above code, we can see the `src` attribute is retrieving the `logo.png` file from the `/images/` directory. We can visit `<WEB_APP_ADDRESS>/images/` to see if indexing is enabled.

<figure><img src="../../.gitbook/assets/Screenshot 2024-05-07 195319.png" alt=""><figcaption></figcaption></figure>

## Manipulating Host Header

It is possible the web app is designed to respond differently if the request comes from a verified IP address such as `127.0.0.1`. To verify this, we can send a benign request through `curl` but with a manipulated host header.

```bash
curl http://example.com -H "Host: 127.0.0.1"
```

If this results in a different response, we can further use this information to bypass any Forbidden Access responses.

## Common Endpoints

Some of the commonly found pages and directories in web apps include:

* robots.txt
* security.txt
* admin
* login

Although the above list is pretty common, it's always smarter to take a look at some visible directories on the web app and try to guess some hidden directories based on the structure and idea of the particular web app. After we exhaust these options, we can move on to directory and subdomain fuzzing.

## Directory Fuzzing

Several tools can be used for directory fuzzing in a web app. Some of the most powerful ones are [Wfuzz](https://github.com/xmendez/wfuzz), [FFUF](https://github.com/ffuf/ffuf) and [Gobuster](https://github.com/OJ/gobuster).

### Wfuzz

Wfuzz is written in Python and can be installed from its GitHub repository or directory from the Linux command line.

```bash
$ sudo apt install wfuzz
```

#### Usage:

<pre class="language-bash"><code class="lang-bash"><strong>$ wfuzz -c -w /usr/share/wordlists/dirb/common.txt http://example.com/FUZZ
</strong></code></pre>

* `-w`: used for specifying the wordlist
* `-c`: wfuzz will use different colours in the response for readability
* `FUZZ`: this keyword is necessary to be inserted at the endpoint to be fuzzed

### FFUF

FFUF is written in Go and similar to wfuzz, it can be installed from the GitHub repository or directory from the command line.

```bash
$ sudo apt install ffuf
```

#### Usage:

```bash
$ ffuf -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://report.comprezzor.htb/FUZZ
```

* `-w`: path to the wordlist
* `-u`: url to the web app for fuzzing
* `FUZZ`: unlike wfuzz, ffuf requires the FUZZ keyword to be included in both wordlist and the url

### Gobuster

Gobuster is also written in Go and can be installed both from the GitHub repository as well as from the command line.

```bash
$ sudo apt install gobuster
```

#### Usage:

```bash
$ gobuster dir -u http://report.comprezzor.htb -w /usr/share/wordlists/dirb/common.txt
```

* `dir`: this keyword tells gobuster that we are running a directory fuzz
* `-u`: url for the web app to fuzz
* `-w`: path to the wordlist

There are many other Directory Fuzzing tools that can perform several functions. It's always a good idea to learn about more than one tool so we can utilise the full benefit of directory fuzzing.

## Subdomain Fuzzing

Several tools can be used to fuzz for potential subdomains. These include command line tools as `subfinder` and websites such as [crt.sh](https://crt.sh/).&#x20;

### Subfinder

Subfinder is written in Go and can be installed from the GitHub repository.

```bash
$ go install -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest
```

#### Usage:

```bash
$ subfinder -d yahoo.com > urls.txt
```

* `-d`: This flag tells subfinder that the following string is the domain
* `yahoo.com`: This is the domain name
* `> urls.txt`: This is a Linux functionality which writes all results from the above command into the file `urls.txt`

### crt.sh

[crt.sh](https://crt.sh/) website looks for subdomains registered under the same domain name. This tool is extremely helpful for quickly fuzzing for potential subdomains.

<figure><img src="../../.gitbook/assets/Screenshot 2024-05-20 182515.png" alt=""><figcaption></figcaption></figure>

_**Note:** Make sure you have explicit permission to test subdomains before conducting subdomain fuzzing. Most bug bounty programs only have a specific domain in scope. When the program lists a wildcard in-scope such as `*.yahoo.com` this means that the subdomains of `yahoo.com` can be tested. When in doubt, contact the bug bounty support team for clarification._
